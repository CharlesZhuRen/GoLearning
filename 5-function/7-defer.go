package main

import "fmt"

func main() {
	a := 1
	b := 2
	defer fmt.Println("let's see what happened")
	defer fmt.Println(b)
	fmt.Println(a)
}

// 帅！就是提前谋篇布局，完事从下往上一个个来
// 后进先出 可以想象有一个堆栈
// 特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题
// 比如open后面就马上跟一句defer close，其实是with open的另一种实现
// 当然不仅仅是局限于IO了

//当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。
//当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。
//当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。
