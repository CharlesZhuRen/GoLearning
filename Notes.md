### Why Go?
编译快、执行快、开发快，我全都要！
Less is More!

### 重大事件
1. 大佬的加入
2. Russ：函数也能有自己的方法，让go有了无限可能
3. Adam创建了cryptographic库
4. Docker等大公司牛逼产品完全用go实现/重构

### 特性·并发编程
1. 其并发执行单元是一种称为goroutine的协程
2. 其并发性能并不是永远都很牛，但胜在它的并发编程简单、直接、高效
3. 实现协程间通讯的两种方式
   1. 共享内存型：全局变量+mutex锁实现数据共享
   2. 消息传递型：使用一种独有的channel机制进行异步通讯
4. 高并发是go最大的两点

### 特性·内存回收 GC
1. 通常的GC过程：stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world，恢复服务，同时起一个专门goroutine回收内存到空闲list中以备复用，不物理释放，物理释放由专门线程定期来执行
2. 瓶颈：每次都要扫描所有对象，所以对象数量越多速度就越慢，所以尽量使用对象少的方案，同时考虑链表、map、slice、数组来存储，前两者的每一个元素都是一个对象，后两者各自都是一个对象，因此后两者对GC更有利
3. 在go里，内存会自动回收，只需要new分配内存，不需要释放

### 特性·内存分配
1. 一开始来一块大的，然后被切分成各个大小、等级的块，放入不同的空闲list中
2. 对象分配空间时从list中去除大小合适的内存块，不用的内存重放回空闲list
3. 空闲内存会按照一定策略合并，以减少碎片

### 特性·编译
1. 两种编译器
   1. 建立在GCC基础上的Gccgo
   2. 分别针对x64和x86的一套编译器（6g和8g）
2. 依赖管理：绝大多数开源库都在Github上，在代码的import中加上Github路径就能用了，库会默认下载到project的pkg目录下
3. 没用到的pkg和变量都会编译不通过

### 特性·网络编程
1. 去中心化、分布式
2. 提供了丰富的网络编程接口
3. 高性能HTTP server

### 特性·函数多返回值
1. 跟python差不多

### 特性·交互性
1. 指的是和其他语言交互的能力
2. 和C可以随便交互
3. 不能和C++交互，但有替代方案：
   1. C++编译成动态库，由Go调用C，C再通过dlfcn调用动态库
   2. 使用swig

### 特性·异常处理
1. 普通异常：被调用方返回error对象，调用方判断error对象
2. 严重异常：指中断性panic，比如/0，用defer...recover...panic机制来捕获处理
   1. 一般会内部自动抛出，避免到处都是try catch的情况

### 关于包
1. 文件名与包名没有直接关系，不一定要将文件名与包名定成同一个
2. 文件夹名与报名也没关系
3. 同一个文件夹下的文件只能有一个包名，否则编译报错

### 常用的命名方式
1. 文件
   - 全部采用小写，不采取驼峰，尽量见名思意
   - 测试文件以_test.go结尾，除了测试文件，命名中不出现_
2. package：小写，短命名，不要和标准库冲突，统一用单数形式
3. 变量：驼峰式，遇到特有名词时特有名词根据私有与否全部小写或大写
4. 常量：和变量一样表达清楚意思，不要嫌长，如果模块复杂可以按功能统一定在package下的一个文件里面
5. 接口：单个函数的接口就给函数名加个er，两个的就把函数名拼在一起，三个以上函数的接口就类似于结构提名
6. 结构体：名词或名词短语，如Account，避免使用Manager这种带er的，如果该数据结构需要序列化，那么首字母大写
7. 方法：动词或动词短语，驼峰式，将功能和必要的参数体现在名字中，如getUserInfo

### 文件结构
- cmd：项目主干，编译构建的入口，其中的代码要尽量简洁，main里面只写参数初始化、配置加载、服务启动
  - app1
    - main.go
  - app2
    - main.go
- pkg：可供项目内外使用的公共性代码，也可以把它命名为lib
- internal：提供一个项目级别的代码保护方式，其中的代码仅供项目内部使用，通过命名对目录的共享范围做区分
- go.mod && go.sum 采用go modules进行依赖管理所生成的配置文件
- Makefile 存放项目的编译部署脚本

### 注释
1. 包注释
   > // util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。\
     // 创建人： hanru\
     // 创建时间： 20190419
2. 结构体、接口注释
   > // User ， 用户对象，定义了用户的基础信息\
   type User struct{\
   Username  string // 用户名\
   Email     string // 邮箱\
   }
3. 函数、方法（结构体或者接口下的函数称为方法）注释
    > // NewtAttrModel ， 属性数据层操作类的工厂方法\
   // 参数：\
   //      ctx ： 上下文信息\
   // 返回值：\
   //      属性操作类指针\
   func NewAttrModel(ctx *common.Context) *AttrModel {\
   }

### 字符串格式化符号
    %v	按值的本来值输出
    %+v	在 %v 基础上，对结构体字段名和值进行展开
    %#v	输出 Go 语言语法格式的值
    %T	输出 Go 语言语法格式的类型和值
    %%	输出 % 本体
    %b	整型以二进制方式显示
    %o	整型以八进制方式显示
    %d	整型以十进制方式显示
    %x	整型以十六进制方式显示
    %X	整型以十六进制、字母大写方式显示
    %U	Unicode 字符
    %f	浮点数
    %p	指针，十六进制方式显示

### type关键字
1. 类型定义
   1. 定义结构体 type person struct
   2. 定义接口 type usb interface
   3. 定义其他新类型 type name type
   4. 定义函数的类型 i.e.9-5-type func
2. 类型别名 type 别名=type
   1. 注意：非本地类型不能定义方法，也就是不能随意在为一个类型定义别名之后在本地修改其方法
   2. solution：
      1. 不做取别名操作，而是直接在本地做类型定义
      2. 将别名定义放在原始类型定义的包中
3. 在结构体成员嵌入时使用别名
   1. 我只能说有点奇怪