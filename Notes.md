### Why Go?
编译快、执行快、开发快，我全都要！
Less is More!

### 重大事件
1. 大佬的加入
2. Russ：函数也能有自己的方法，让go有了无限可能
3. Adam创建了cryptographic库
4. Docker等大公司牛逼产品完全用go实现/重构

### 特性·并发编程
1. 其并发执行单元是一种称为goroutine的协程
2. 其并发性能并不是永远都很牛，但胜在它的并发编程简单、直接、高效
3. 实现协程间通讯的两种方式
   1. 共享内存型：全局变量+mutex锁实现数据共享
   2. 消息传递型：使用一种独有的channel机制进行异步通讯
4. 高并发是go最大的两点

### 特性·内存回收 GC
1. 通常的GC过程：stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world，恢复服务，同时起一个专门goroutine回收内存到空闲list中以备复用，不物理释放，物理释放由专门线程定期来执行
2. 瓶颈：每次都要扫描所有对象，所以对象数量越多速度就越慢，所以尽量使用对象少的方案，同时考虑链表、map、slice、数组来存储，前两者的每一个元素都是一个对象，后两者各自都是一个对象，因此后两者对GC更有利
3. 在go里，内存会自动回收，只需要new分配内存，不需要释放

### 特性·内存分配
1. 一开始来一块大的，然后被切分成各个大小、等级的块，放入不同的空闲list中
2. 对象分配空间时从list中去除大小合适的内存块，不用的内存重放回空闲list
3. 空闲内存会按照一定策略合并，以减少碎片

### 特性·编译
1. 两种编译器
   1. 建立在GCC基础上的Gccgo
   2. 分别针对x64和x86的一套编译器（6g和8g）
2. 依赖管理：绝大多数开源库都在Github上，在代码的import中加上Github路径就能用了，库会默认下载到project的pkg目录下
3. 没用到的pkg和变量都会编译不通过

### 特性·网络编程
1. 去中心化、分布式
2. 提供了丰富的网络编程接口
3. 高性能HTTP server

### 特性·函数多返回值
1. 跟python差不多

### 特性·交互性
1. 指的是和其他语言交互的能力
2. 和C可以随便交互
3. 不能和C++交互，但有替代方案：
   1. C++编译成动态库，由Go调用C，C再通过dlfcn调用动态库
   2. 使用swig

### 特性·异常处理
1. 普通异常：被调用方返回error对象，调用方判断error对象
2. 严重异常：指中断性panic，比如/0，用defer...recover...panic机制来捕获处理
   1. 一般会内部自动抛出，避免到处都是try catch的情况

### 关于包
1. 文件名与包名没有直接关系，不一定要将文件名与包名定成同一个
2. 文件夹名与报名也没关系
3. 同一个文件夹下的文件只能有一个包名，否则编译报错
4. 同一个包下面的文件属于同一个工程文件，不用import包，可以直接使用
5. 导入包时使用 import ."fmt"的含义是，在调用这个包的函数时可以省略前缀的包名，类似于python中的from fmt import *
6. 起别名：import p1 "package1"
7. _操作：import _ "github.com/zhuren/mysql/zz" 只执行该包内的import，而不直接使用包里的函数
8. import时建议使用绝对路径

### 常用的命名方式
1. 文件
   - 全部采用小写，不采取驼峰，尽量见名思意
   - 测试文件以_test.go结尾，除了测试文件，命名中不出现_
2. package：小写，短命名，不要和标准库冲突，统一用单数形式
3. 变量：驼峰式，遇到特有名词时特有名词根据私有与否全部小写或大写
4. 常量：和变量一样表达清楚意思，不要嫌长，如果模块复杂可以按功能统一定在package下的一个文件里面
5. 接口：单个函数的接口就给函数名加个er，两个的就把函数名拼在一起，三个以上函数的接口就类似于结构提名
6. 结构体：名词或名词短语，如Account，避免使用Manager这种带er的，如果该数据结构需要序列化，那么首字母大写
7. 方法：动词或动词短语，驼峰式，将功能和必要的参数体现在名字中，如getUserInfo

### 文件结构
- cmd：项目主干，编译构建的入口，其中的代码要尽量简洁，main里面只写参数初始化、配置加载、服务启动
  - app1
    - main.go
  - app2
    - main.go
- pkg：可供项目内外使用的公共性代码，也可以把它命名为lib
- internal：提供一个项目级别的代码保护方式，其中的代码仅供项目内部使用，通过命名对目录的共享范围做区分
- go.mod && go.sum 采用go modules进行依赖管理所生成的配置文件
- Makefile 存放项目的编译部署脚本

### 注释
1. 包注释
   > // util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。\
     // 创建人： hanru\
     // 创建时间： 20190419
2. 结构体、接口注释
   > // User ， 用户对象，定义了用户的基础信息\
   type User struct{\
   Username  string // 用户名\
   Email     string // 邮箱\
   }
3. 函数、方法（结构体或者接口下的函数称为方法）注释
    > // NewtAttrModel ， 属性数据层操作类的工厂方法\
   // 参数：\
   //      ctx ： 上下文信息\
   // 返回值：\
   //      属性操作类指针\
   func NewAttrModel(ctx *common.Context) *AttrModel {\
   }

### 字符串格式化符号
    %v	按值的本来值输出
    %+v	在 %v 基础上，对结构体字段名和值进行展开
    %#v	输出 Go 语言语法格式的值
    %T	输出 Go 语言语法格式的类型和值
    %%	输出 % 本体
    %b	整型以二进制方式显示
    %o	整型以八进制方式显示
    %d	整型以十进制方式显示
    %x	整型以十六进制方式显示
    %X	整型以十六进制、字母大写方式显示
    %U	Unicode 字符
    %f	浮点数
    %p	指针，十六进制方式显示

### type关键字
1. 类型定义
   1. 定义结构体 type person struct
   2. 定义接口 type usb interface
   3. 定义其他新类型 type name type
   4. 定义函数的类型 i.e.9-5-type func
2. 类型别名 type 别名=type
   1. 注意：非本地类型不能定义方法，也就是不能随意在为一个类型定义别名之后在本地修改其方法
   2. solution：
      1. 不做取别名操作，而是直接在本地做类型定义
      2. 将别名定义放在原始类型定义的包中
3. 在结构体成员嵌入时使用别名
   1. 我只能说有点奇怪

### error
1. 错误指的是可能出现问题的地方出现了问题，比如打开文件失败，这在意料之中
   1. 异常指的是不该出现问题的地方出现了问题，这在意料之外
   2. 所以说错误是业务的一部分，异常不是
2. 错误是一种接口类型
3. 获取错误信息的方式
   1. 断言底层结构类型并从结构字段获取更多信息 i.e.10-2
   2. 断言底层结构类型，并使用方法获取更多信息 i.e.10-3
   3. 直接比较 i.e.10-4
4. panic
   1. 若函数F中写了panic，终止其后代码，并将其内的defer函数逆序执行
   2. 返回函数的调用者G，G中调用F之后的代码不会被执行，若存在defer则逆序执行
   3. 直到goroutine整个退出，报告错误
5. recover
   1. go中可以抛出一个panic的异常，然后在defer中用recover捕获这个异常，然后正常处理
6. 错误和异常的区别其实就相当于error和panic的区别
   1. 二者还可以互相转换
      1. 错误转异常：比如url请求三次还不成功就从错误转异常了
      2. 异常转错误：比如panic触发的异常被recover恢复后，将error类型的变量进行赋值，以便上层函数继续走错误处理流程
7. 异常处理的场景：
   1. 空指针引用
   2. 下标越界
   3. 除数为0
   4. 不该出现的分支，比如default
   5. 输入不应引起函数错误
   6. 其他情况都用error处理
8. 处理错误
   1. 只有一个失败的原因时不用error
   2. 没有失败时不用error
   3. error应放在返回值类型列表的最后
   4. 错误值统一定义，在每个包中增加一个错误对象定义文件
   5. 错误逐层传递时，层层都加日志
   6. 错误处理使用defer
   7. 如果尝试几次能够避免失败，不要急于返回错误
   8. 上层函数不关心错误时就不要返回
   9. 发生错误时不要忽略有用的返回值
9. 处理异常
   1. 开发阶段要想办法让它挂，这样才能及早发现问题
   2. 程序部署后，应恢复异常避免程序终止
   3. 用异常处理不应出现的分支：panic(fmt.Sprintf("invalid suit %v", s))
   4. 使用panic设计入参不应该有问题的函数

### init和main
1. 这俩叫保留函数
2. init会在包被导入时执行，用于初始化包所需要的特定资料 i.e.11-1
3. 相同点
   1. 在定义时不能有任何的参数和返回值，只能由go自动调用，不能被引用
4. 不同点
   1. init可以用在任意包中，可以重复定义多个
   2. main只能用于一个main包中，且只能定义一个
5. 执行顺序
   1. main包中的go文件默认总是会被执行
   2. 对同一个go文件的init调用顺序是从上到下的
   3. 对同一个package中的不同文件，将文件名按字符串进行从小到大排序，之后顺序调用各文件中的init函数
   4. 对于不同的package，如果不相互依赖的话，按照main包中import的顺序调用其包中的init函数
   5. 如果package存在依赖，调用顺序为最后被依赖的最先被初始化，因此main包总是最后一个被初始化，因为他依赖别人最多

### Concurrency
1. the ability to execute many tasks
2. Go is a concurrent language and not a parallel one -> concurrency is different from parallelism
   1. concurrency: jogging, stop, tie his shoes, jogging -> do A, switch to do B, switch to do A
   2. parallelism: jogging and listening to music at the same time -> do A and B at the same time
3. Process, Thread, Coroutine 
   1. Process 进程: 一个程序在一个数据集中的一次动态执行过程，aka “正在执行的程序”
      1. 程序，数据集，进程控制块三部分组成
      2. limitation：创建、撤销、切换的开销比较大
   2. Thread:
      1. a basic cpu execution unit, also the least unit during program execution
      2. pros 线程:
         1. 减小程序并发执行时的开销
         2. 提高操作系统的并发性能
      3. cons:
         1. 没有自己的系统资源，只拥有在运行时必不可少的资源， but 同一进程的各个线程可以共享进程所拥有的系统资源
         2. 对于某些独占性资源存在锁机制，处理不当可能产生死锁
   3. Coroutine 协程 微线程：
      1. 用户态的轻量级线程，也叫微线程
      2. 其调度完全由用户控制
      3. pros:
         1. 创建上百万个也不会导致系统资源衰竭，而进程和线程通常最多不能超过一万个
         2. compared to multithreading: 子程序切换是由程序自身控制，执行效率极高，没有线程切换的开销
         3. compared to multiprocessing: 线程数量越多，协程的性能优势就越明显
      4. go对于并发的实现就是靠协程

### Goroutine
1. pros
   1. cheap：只是堆栈大小的几个kb，可以根据应用程序的需要增长和收缩
      > 如果是在线程的情况下，堆栈大小就必须是指定且固定的了
   2. 被多路复用到较少的OS线程，使得我们开发的时候不需要在意这些复杂的细节
   3. 使用它访问共享内存时，通过设计的通道可以防止竞态条件发生
2. 主goroutine
   1. 设定每个goroutine所能申请的栈空间的最大尺寸，32位：250mb；64位：1gb，运行时超出则会StackOverflow+终止运行
   2. 执行一系列初始化工作
      1. 启动专用于在后台清扫内存垃圾的goroutine，并设置GC可用的标识
      2. 执行main包中的init
      3. 执行main
      4. 检查主goroutine是否引发了runtime panic，并进行必要的处理
      5. 结束自己以及当前进程的执行
3. tips
   1. 新的goroutine开始时，goroutine调用立即返回，然后立即执行下一行代码
   2. 如果main的Goroutine终止了，程序将被终止，而其他Goroutine将不会运行