### Why Go?
编译快、执行快、开发快，我全都要！
Less is More!

### 重大事件
1. 大佬的加入
2. Russ：函数也能有自己的方法，让go有了无限可能
3. Adam创建了cryptographic库
4. Docker等大公司牛逼产品完全用go实现/重构

### 特性·并发编程
1. 其并发执行单元是一种称为goroutine的协程
2. 其并发性能并不是永远都很牛，但胜在它的并发编程简单、直接、高效
3. 实现协程间通讯的两种方式
   1. 共享内存型：全局变量+mutex锁实现数据共享
   2. 消息传递型：使用一种独有的channel机制进行异步通讯
4. 高并发是go最大的两点

### 特性·内存回收 GC
1. 通常的GC过程：stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world，恢复服务，同时起一个专门goroutine回收内存到空闲list中以备复用，不物理释放，物理释放由专门线程定期来执行
2. 瓶颈：每次都要扫描所有对象，所以对象数量越多速度就越慢，所以尽量使用对象少的方案，同时考虑链表、map、slice、数组来存储，前两者的每一个元素都是一个对象，后两者各自都是一个对象，因此后两者对GC更有利
3. 在go里，内存会自动回收，只需要new分配内存，不需要释放

### 特性·内存分配
1. 一开始来一块大的，然后被切分成各个大小、等级的块，放入不同的空闲list中
2. 对象分配空间时从list中去除大小合适的内存块，不用的内存重放回空闲list
3. 空闲内存会按照一定策略合并，以减少碎片

### 特性·编译
1. 两种编译器
   1. 建立在GCC基础上的Gccgo
   2. 分别针对x64和x86的一套编译器（6g和8g）
2. 依赖管理：绝大多数开源库都在Github上，在代码的import中加上Github路径就能用了，库会默认下载到project的pkg目录下
3. 没用到的pkg和变量都会编译不通过

### 特性·网络编程
1. 去中心化、分布式
2. 提供了丰富的网络编程接口
3. 高性能HTTP server

### 特性·函数多返回值
1. 跟python差不多

### 特性·交互性
1. 指的是和其他语言交互的能力
2. 和C可以随便交互
3. 不能和C++交互，但有替代方案：
   1. C++编译成动态库，由Go调用C，C再通过dlfcn调用动态库
   2. 使用swig

### 特性·异常处理
1. 普通异常：被调用方返回error对象，调用方判断error对象
2. 严重异常：指中断性panic，比如/0，用defer...recover...panic机制来捕获处理
   1. 一般会内部自动抛出，避免到处都是try catch的情况

### 关于包
1. 文件名与包名没有直接关系，不一定要将文件名与包名定成同一个
2. 文件夹名与报名也没关系
3. 同一个文件夹下的文件只能有一个包名，否则编译报错

### 常用的命名方式
1. 文件
   - 全部采用小写，不采取驼峰，尽量见名思意
   - 测试文件以_test.go结尾，除了测试文件，命名中不出现_
2. package：小写，短命名，不要和标准库冲突，统一用单数形式
3. 变量：驼峰式，遇到特有名词时特有名词根据私有与否全部小写或大写
4. 常量：和变量一样表达清楚意思，不要嫌长，如果模块复杂可以按功能统一定在package下的一个文件里面
5. 接口：单个函数的接口就给函数名加个er，两个的就把函数名拼在一起，三个以上函数的接口就类似于结构提名
6. 结构体：名词或名词短语，如Account，避免使用Manager这种带er的，如果该数据结构需要序列化，那么首字母大写
7. 方法：动词或动词短语，驼峰式，将功能和必要的参数体现在名字中，如getUserInfo

### 文件结构
- cmd：项目主干，编译构建的入口，其中的代码要尽量简洁，main里面只写参数初始化、配置加载、服务启动
  - app1
    - main.go
  - app2
    - main.go
- pkg：可供项目内外使用的公共性代码，也可以把它命名为lib
- internal：提供一个项目级别的代码保护方式，其中的代码仅供项目内部使用，通过命名对目录的共享范围做区分
- go.mod && go.sum 采用go modules进行依赖管理所生成的配置文件
- Makefile 存放项目的编译部署脚本

### 注释
1. 包注释
   > // util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。\
     // 创建人： hanru\
     // 创建时间： 20190419
2. 结构体、接口注释
   > // User ， 用户对象，定义了用户的基础信息\
   type User struct{\
   Username  string // 用户名\
   Email     string // 邮箱\
   }
3. 函数、方法（结构体或者接口下的函数称为方法）注释
    > // NewtAttrModel ， 属性数据层操作类的工厂方法\
   // 参数：\
   //      ctx ： 上下文信息\
   // 返回值：\
   //      属性操作类指针\
   func NewAttrModel(ctx *common.Context) *AttrModel {\
   }

### 字符串格式化符号
    %v	按值的本来值输出
    %+v	在 %v 基础上，对结构体字段名和值进行展开
    %#v	输出 Go 语言语法格式的值
    %T	输出 Go 语言语法格式的类型和值
    %%	输出 % 本体
    %b	整型以二进制方式显示
    %o	整型以八进制方式显示
    %d	整型以十进制方式显示
    %x	整型以十六进制方式显示
    %X	整型以十六进制、字母大写方式显示
    %U	Unicode 字符
    %f	浮点数
    %p	指针，十六进制方式显示

### type关键字
1. 类型定义
   1. 定义结构体 type person struct
   2. 定义接口 type usb interface
   3. 定义其他新类型 type name type
   4. 定义函数的类型 i.e.9-5-type func
2. 类型别名 type 别名=type
   1. 注意：非本地类型不能定义方法，也就是不能随意在为一个类型定义别名之后在本地修改其方法
   2. solution：
      1. 不做取别名操作，而是直接在本地做类型定义
      2. 将别名定义放在原始类型定义的包中
3. 在结构体成员嵌入时使用别名
   1. 我只能说有点奇怪

### error
1. 错误指的是可能出现问题的地方出现了问题，比如打开文件失败，这在意料之中
   1. 异常指的是不该出现问题的地方出现了问题，这在意料之外
   2. 所以说错误是业务的一部分，异常不是
2. 错误是一种接口类型
3. 获取错误信息的方式
   1. 断言底层结构类型并从结构字段获取更多信息 i.e.10-2
   2. 断言底层结构类型，并使用方法获取更多信息 i.e.10-3
   3. 直接比较 i.e.10-4
4. panic
   1. 若函数F中写了panic，终止其后代码，并将其内的defer函数逆序执行
   2. 返回函数的调用者G，G中调用F之后的代码不会被执行，若存在defer则逆序执行
   3. 直到goroutine整个退出，报告错误
5. recover
   1. go中可以抛出一个panic的异常，然后在defer中用recover捕获这个异常，然后正常处理
6. 错误和异常的区别其实就相当于error和panic的区别
   1. 二者还可以互相转换
      1. 错误转异常：比如url请求三次还不成功就从错误转异常了
      2. 异常转错误：比如panic触发的异常被recover恢复后，将error类型的变量进行赋值，以便上层函数继续走错误处理流程
7. 异常处理的场景：
   1. 空指针引用
   2. 下标越界
   3. 除数为0
   4. 不该出现的分支，比如default
   5. 输入不应引起函数错误
   6. 其他情况都用error处理
8. 处理错误
   1. 只有一个失败的原因时不用error
   2. 没有失败时不用error
   3. error应放在返回值类型列表的最后
   4. 错误值统一定义，在每个包中增加一个错误对象定义文件
   5. 错误逐层传递时，层层都加日志
   6. 错误处理使用defer
   7. 如果尝试几次能够避免失败，不要急于返回错误
   8. 上层函数不关心错误时就不要返回
   9. 发生错误时不要忽略有用的返回值
9. 处理异常
   1. 开发阶段要想办法让它挂，这样才能及早发现问题
   2. 程序部署后，应恢复异常避免程序终止
   3. 用异常处理不应出现的分支：panic(fmt.Sprintf("invalid suit %v", s))
   4. 使用panic设计入参不应该有问题的函数